     1                                  %include "io.inc"
     2                              <1> %ifndef IO_SYS
     3                              <1> %define IO_SYS
     4                              <1> 
     5                              <1> %macro sasmMacroFunc 0.nolist ;func for debug
     6                              <1>     %push sasmMacroFunc
     7                              <1>     call %$sasmMacro
     8                              <1>     jmp %$sasmMacroE
     9                              <1>     %$sasmMacro:
    10                              <1>     jmp %%after_data
    11                              <1> section .data
    12                              <1>     %$sasmRetAddr dd 0
    13                              <1> section .text
    14                              <1>     %%after_data:
    15                              <1>     push ebx
    16                              <1>     mov ebx, dword[esp + 4]
    17                              <1>     mov dword[%$sasmRetAddr], ebx
    18                              <1>     mov ebx, dword[esp]
    19                              <1>     mov dword[esp + 4], ebx
    20                              <1>     pop ebx
    21                              <1>     pop ebx
    22                              <1> %endmacro
    23                              <1> 
    24                              <1> %macro sasmMacroFuncE 0.nolist ;exit
    25                              <1>     push dword[%$sasmRetAddr]
    26                              <1>     ret
    27                              <1>     %$sasmMacroE:
    28                              <1>     %pop
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> %macro CEXTERN 1.nolist
    32                              <1>     extern %1
    33                              <1> %endmacro
    34                              <1> %define CMAIN main
    35                              <1> 
    36                              <1> CEXTERN printf
    37                              <1> CEXTERN scanf
    38                              <1> CEXTERN putchar
    39                              <1> CEXTERN fgets
    40                              <1> CEXTERN puts
    41                              <1> CEXTERN fputs
    42                              <1> CEXTERN fflush
    43                              <1> 
    44                              <1> CEXTERN get_stdin
    45                              <1> CEXTERN get_stdout
    46                              <1> 
    47                              <1> ; Make stack be 16 bytes aligned after pushing %1 bytes
    48                              <1> %macro ALIGN_STACK 1.nolist
    49                              <1>     enter 0, 0
    50                              <1>     sub esp, %1
    51                              <1>     and esp, 0xfffffff0
    52                              <1>     add esp, %1
    53                              <1> %endmacro
    54                              <1> 
    55                              <1> %macro UNALIGN_STACK 0.nolist
    56                              <1>     leave
    57                              <1> %endmacro
    58                              <1> 
    59                              <1> %macro FFLUSH_STDOUT 0.nolist
    60                              <1>     ALIGN_STACK 4
    61                              <1>     call get_stdout
    62                              <1>     push eax
    63                              <1>     call fflush
    64                              <1>     UNALIGN_STACK
    65                              <1> %endmacro
    66                              <1> 
    67                              <1> %macro IS_GPR 1.nolist
    68                              <1>     %push IS_GPR
    69                              <1>     %assign %$is_reg 0
    70                              <1>     %assign %$reg_size 1
    71                              <1>     %ifidni %1, ah
    72                              <1>         %assign %$is_reg 1
    73                              <1>     %elifidni %1, al
    74                              <1>         %assign %$is_reg 1
    75                              <1>     %elifidni %1, bl
    76                              <1>         %assign %$is_reg 1
    77                              <1>     %elifidni %1, bh
    78                              <1>         %assign %$is_reg 1
    79                              <1>     %elifidni %1, cl
    80                              <1>         %assign %$is_reg 1
    81                              <1>     %elifidni %1, ch
    82                              <1>         %assign %$is_reg 1
    83                              <1>     %elifidni %1, dl
    84                              <1>         %assign %$is_reg 1
    85                              <1>     %elifidni %1, dh
    86                              <1>         %assign %$is_reg 1
    87                              <1>     %elifidni %1, ax
    88                              <1>         %assign %$is_reg 1
    89                              <1>         %assign %$reg_size 2
    90                              <1>     %elifidni %1, bx
    91                              <1>         %assign %$is_reg 1
    92                              <1>         %assign %$reg_size 2
    93                              <1>     %elifidni %1, cx
    94                              <1>         %assign %$is_reg 1
    95                              <1>         %assign %$reg_size 2
    96                              <1>     %elifidni %1, dx
    97                              <1>         %assign %$is_reg 1
    98                              <1>         %assign %$reg_size 2
    99                              <1>     %elifidni %1, sp
   100                              <1>         %assign %$is_reg 1
   101                              <1>         %assign %$reg_size 2
   102                              <1>     %elifidni %1, bp
   103                              <1>         %assign %$is_reg 1
   104                              <1>         %assign %$reg_size 2
   105                              <1>     %elifidni %1, si
   106                              <1>         %assign %$is_reg 1
   107                              <1>         %assign %$reg_size 2
   108                              <1>     %elifidni %1, di
   109                              <1>         %assign %$is_reg 1
   110                              <1>         %assign %$reg_size 2
   111                              <1>     %elifidni %1, eax
   112                              <1>         %assign %$is_reg 1
   113                              <1>         %assign %$reg_size 4
   114                              <1>     %elifidni %1, ebx
   115                              <1>         %assign %$is_reg 1
   116                              <1>         %assign %$reg_size 4
   117                              <1>     %elifidni %1, ecx
   118                              <1>         %assign %$is_reg 1
   119                              <1>         %assign %$reg_size 4
   120                              <1>     %elifidni %1, edx
   121                              <1>         %assign %$is_reg 1
   122                              <1>         %assign %$reg_size 4
   123                              <1>     %elifidni %1, esp
   124                              <1>         %assign %$is_reg 1
   125                              <1>         %assign %$reg_size 4
   126                              <1>     %elifidni %1, ebp
   127                              <1>         %assign %$is_reg 1
   128                              <1>         %assign %$reg_size 4
   129                              <1>     %elifidni %1, esi
   130                              <1>         %assign %$is_reg 1
   131                              <1>         %assign %$reg_size 4
   132                              <1>     %elifidni %1, edi
   133                              <1>         %assign %$is_reg 1
   134                              <1>         %assign %$reg_size 4
   135                              <1>     %endif
   136                              <1> %endmacro
   137                              <1> 
   138                              <1> 
   139                              <1> %macro PRINT_STRING 1.nolist
   140                              <1>     sasmMacroFunc
   141                              <1>     IS_GPR %1
   142                              <1>     %if %$is_reg = 1
   143                              <1>     %error "Register as parameter is not supported"
   144                              <1>     %endif
   145                              <1>     %pop
   146                              <1> 
   147                              <1> %ifid %1
   148                              <1> ; variable
   149                              <1>     pushf
   150                              <1>     push edx
   151                              <1>     push ecx
   152                              <1>     push eax	
   153                              <1> 
   154                              <1>     ALIGN_STACK 0
   155                              <1>     call get_stdout
   156                              <1>     UNALIGN_STACK
   157                              <1>     ALIGN_STACK 8
   158                              <1>     push eax 
   159                              <1>     push %1
   160                              <1> 
   161                              <1> %elifstr %1
   162                              <1> ; string literal
   163                              <1>     pushf
   164                              <1>     push edx
   165                              <1>     push ecx
   166                              <1>     push eax	
   167                              <1> 
   168                              <1>     jmp %%after_str
   169                              <1>     %%str	db	%1, 0
   170                              <1> %%after_str:	
   171                              <1>     ALIGN_STACK 0
   172                              <1>     call get_stdout
   173                              <1>     UNALIGN_STACK
   174                              <1>     ALIGN_STACK 8
   175                              <1>     push eax
   176                              <1>     push %%str
   177                              <1> 
   178                              <1> %else
   179                              <1> ; address expression
   180                              <1>     jmp %%after_data
   181                              <1> section .data
   182                              <1>     %%tmp dd 0
   183                              <1> section .text
   184                              <1> %%after_data:
   185                              <1>     mov dword [%%tmp], edi
   186                              <1>     lea edi, %1
   187                              <1> 
   188                              <1>     pushf
   189                              <1>     push edx
   190                              <1>     push ecx
   191                              <1>     push eax
   192                              <1> 
   193                              <1>     ALIGN_STACK 0
   194                              <1>     call get_stdout
   195                              <1>     UNALIGN_STACK
   196                              <1>     ALIGN_STACK 8
   197                              <1>     push eax
   198                              <1>     push edi
   199                              <1> 
   200                              <1>     mov edi, dword [%%tmp]
   201                              <1>     
   202                              <1> %endif
   203                              <1> 
   204                              <1>     call fputs
   205                              <1>     UNALIGN_STACK
   206                              <1>     FFLUSH_STDOUT
   207                              <1>     pop eax
   208                              <1>     pop ecx
   209                              <1>     pop edx
   210                              <1>     popf
   211                              <1>     sasmMacroFuncE
   212                              <1> %endmacro
   213                              <1> 
   214                              <1> %macro NEWLINE 0.nolist
   215                              <1>     PRINT_STRING `\n`
   216                              <1> %endmacro
   217                              <1> 
   218                              <1> ; size baseformatletter ("d", "u", "x") varname (%%fmt)
   219                              <1> %macro ___MAKE_FORMAT_STR 3.nolist
   220                              <1>     jmp %%after_fmt
   221                              <1>     %if %1 = 1
   222                              <1>         %strcat fmts "%hh" %2
   223                              <1>         
   224                              <1>     %elif %1 = 2
   225                              <1>         %strcat fmts "%h" %2
   226                              <1>     %elif %1 = 4
   227                              <1>         %strcat fmts "%" %2
   228                              <1>     %else
   229                              <1>         %error "Expected numeric constant 1, 2 or 4 as 1st argument"
   230                              <1>     %endif
   231                              <1>     %3 db fmts, 0
   232                              <1>     %%after_fmt:
   233                              <1> %endmacro
   234                              <1> 
   235                              <1> ; size data baseformatletter ("d", "u", "x") signextendinst (movzx, movsx)
   236                              <1> %macro ___PRINT_NUM_COMMON 4.nolist
   237                              <1>     ___MAKE_FORMAT_STR %1, %3, %%fmt
   238                              <1>         
   239                              <1>     jmp %%after_data
   240                              <1> section .data
   241                              <1>     %%tmp dd 0
   242                              <1> 
   243                              <1> section .text
   244                              <1> %%after_data:
   245                              <1> 
   246                              <1>     IS_GPR %2
   247                              <1> 
   248                              <1> %if %$is_reg = 1
   249                              <1> ; register
   250                              <1> 
   251                              <1>     mov dword [%%tmp], eax    ; may be register is esp, need to take care
   252                              <1> 
   253                              <1>     %if %$reg_size = 1
   254                              <1>         %4 eax, %2
   255                              <1>     %elif %$reg_size = 2
   256                              <1>         %4 eax, %2
   257                              <1>     %else ; %$reg_size = 4
   258                              <1>         mov eax, %2
   259                              <1>     %endif
   260                              <1> 
   261                              <1>     pushf
   262                              <1>     push dword [%%tmp] ; eax
   263                              <1>     push ecx
   264                              <1>     push edx
   265                              <1> 
   266                              <1>     ALIGN_STACK 8
   267                              <1>     push eax
   268                              <1> 
   269                              <1> %elifid %2
   270                              <1> ; variable (hope so)
   271                              <1>     pushf
   272                              <1>     push eax
   273                              <1>     push ecx
   274                              <1>     push edx
   275                              <1>     
   276                              <1> %if %1 = 1
   277                              <1>     %4 eax, byte [%2]
   278                              <1> %elif %1 = 2
   279                              <1>     %4 eax, word [%2]
   280                              <1> %else ; %1 = 4
   281                              <1>     mov eax, dword [%2]
   282                              <1> %endif
   283                              <1> 
   284                              <1>     ALIGN_STACK 8
   285                              <1>     push eax
   286                              <1> 
   287                              <1> %elifnum %2
   288                              <1>     pushf
   289                              <1>     push eax
   290                              <1>     push ecx
   291                              <1>     push edx
   292                              <1> 
   293                              <1>     ALIGN_STACK 8
   294                              <1>     push %2
   295                              <1> %elifstr %2
   296                              <1>     pushf
   297                              <1>     push eax
   298                              <1>     push ecx
   299                              <1>     push edx
   300                              <1> 
   301                              <1>     ALIGN_STACK 8
   302                              <1>     push %2
   303                              <1> 
   304                              <1> %else
   305                              <1> ; may be, address expression?
   306                              <1>     
   307                              <1>     mov dword [%%tmp], eax    ; may use register esp, need to take care
   308                              <1> 
   309                              <1>     %if %1 = 1
   310                              <1>         %4 eax, byte %2
   311                              <1>     %elif %1 = 2
   312                              <1>         %4 eax, word %2
   313                              <1>     %else ; %1 = 4
   314                              <1>         mov eax, dword %2
   315                              <1>     %endif
   316                              <1> 
   317                              <1>     pushf
   318                              <1>     push dword [%%tmp] ; eax
   319                              <1>     push ecx
   320                              <1>     push edx
   321                              <1> 
   322                              <1>     ALIGN_STACK 8
   323                              <1>     push eax
   324                              <1> 
   325                              <1> %endif
   326                              <1> 
   327                              <1>     push %%fmt
   328                              <1>     call printf
   329                              <1>     UNALIGN_STACK
   330                              <1>     FFLUSH_STDOUT
   331                              <1> 
   332                              <1>     pop edx
   333                              <1>     pop ecx
   334                              <1>     pop eax
   335                              <1>     popf    
   336                              <1> 
   337                              <1>     %pop ; IS_REG
   338                              <1>     
   339                              <1> %endmacro
   340                              <1> 
   341                              <1> %macro PRINT_DEC 2.nolist
   342                              <1>     sasmMacroFunc
   343                              <1>     ___PRINT_NUM_COMMON %1, %2, "d", movsx
   344                              <1>     sasmMacroFuncE
   345                              <1> %endmacro
   346                              <1> 
   347                              <1> %macro PRINT_UDEC 2.nolist
   348                              <1>     sasmMacroFunc
   349                              <1>     ___PRINT_NUM_COMMON %1, %2, "u", movzx
   350                              <1>     sasmMacroFuncE
   351                              <1> %endmacro
   352                              <1> 
   353                              <1> %macro PRINT_HEX 2.nolist
   354                              <1>     sasmMacroFunc
   355                              <1>     ___PRINT_NUM_COMMON %1, %2, "x", movzx
   356                              <1>     sasmMacroFuncE
   357                              <1> %endmacro
   358                              <1> 
   359                              <1> %macro PRINT_CHAR 1.nolist
   360                              <1>     sasmMacroFunc
   361                              <1> 
   362                              <1>     jmp %%after_data
   363                              <1> section .data
   364                              <1>     %%tmp dd 0
   365                              <1> 
   366                              <1> section .text
   367                              <1> %%after_data:
   368                              <1> 
   369                              <1>     IS_GPR %1
   370                              <1> 
   371                              <1> %if %$is_reg = 1
   372                              <1> ; register
   373                              <1> 
   374                              <1>     mov dword [%%tmp], eax    ; may be register is esp, need to take care
   375                              <1> 
   376                              <1>     %if %$reg_size = 1
   377                              <1>         movzx eax, %1
   378                              <1>     %elif %$reg_size = 2
   379                              <1>         movzx eax, %1
   380                              <1>     %else ; %$reg_size = 4
   381                              <1>         mov eax, %1
   382                              <1>     %endif
   383                              <1> 
   384                              <1>     pushf
   385                              <1>     push dword [%%tmp] ; eax
   386                              <1>     push ecx
   387                              <1>     push edx
   388                              <1> 
   389                              <1>     and eax, 0xff
   390                              <1>     ALIGN_STACK 4
   391                              <1>     push eax
   392                              <1> 
   393                              <1> %elifid %1
   394                              <1> ; variable (hope so)
   395                              <1>     pushf
   396                              <1>     push eax
   397                              <1>     push ecx
   398                              <1>     push edx
   399                              <1> 
   400                              <1>     movzx eax, byte [%1]
   401                              <1>     ALIGN_STACK 4    
   402                              <1>     push eax
   403                              <1> 
   404                              <1> %elifnum %1
   405                              <1>     pushf
   406                              <1>     push eax
   407                              <1>     push ecx
   408                              <1>     push edx
   409                              <1> 
   410                              <1>     ALIGN_STACK 4
   411                              <1>     push (%1 & 0xff)
   412                              <1> %elifstr %1
   413                              <1>     pushf
   414                              <1>     push eax
   415                              <1>     push ecx
   416                              <1>     push edx
   417                              <1> 
   418                              <1> ; string; select only 1st byte
   419                              <1> %substr tstr %1 1
   420                              <1>     ALIGN_STACK 4
   421                              <1>     push tstr
   422                              <1> 
   423                              <1> %else
   424                              <1> ; may be, address expression?
   425                              <1>     
   426                              <1>     mov dword [%%tmp], eax    ; may use register esp, need to take care
   427                              <1> 
   428                              <1>     movzx eax, byte %1
   429                              <1> 
   430                              <1>     pushf
   431                              <1>     push dword [%%tmp] ; eax
   432                              <1>     push ecx
   433                              <1>     push edx
   434                              <1> 
   435                              <1>     ALIGN_STACK 4
   436                              <1>     push eax
   437                              <1> 
   438                              <1> %endif
   439                              <1> 
   440                              <1>     call putchar
   441                              <1>     UNALIGN_STACK
   442                              <1>     FFLUSH_STDOUT
   443                              <1> 
   444                              <1>     pop edx
   445                              <1>     pop ecx
   446                              <1>     pop eax
   447                              <1>     popf    
   448                              <1> 
   449                              <1>     %pop ; IS_REG
   450                              <1>     sasmMacroFuncE
   451                              <1> %endmacro
   452                              <1> 
   453                              <1> 
   454                              <1> ; size data baseformatletter ("d", "u", "x") signextendinst (movzx, movsx)
   455                              <1> %macro ___GET_NUM_COMMON 4.nolist
   456                              <1> 
   457                              <1>     ___MAKE_FORMAT_STR %1, %3, %%fmt
   458                              <1>         
   459                              <1>     jmp %%after_data
   460                              <1> section .data
   461                              <1>     %%tmp dd 0
   462                              <1>     %%read_tmp dd 0
   463                              <1> 
   464                              <1> section .text
   465                              <1> %%after_data:
   466                              <1> 
   467                              <1>     IS_GPR %2
   468                              <1> 
   469                              <1> %if %$is_reg = 1
   470                              <1> ; register
   471                              <1> 
   472                              <1>     %ifidni %2, esp
   473                              <1>         %error "Won't read to esp!" 
   474                              <1>     %elifidni %2, sp
   475                              <1>         %error "Won't read to sp!" 
   476                              <1>     %endif
   477                              <1> 
   478                              <1>     %if %$reg_size < %1
   479                              <1>         %error "Too small register for requested data"
   480                              <1>     %endif
   481                              <1> 
   482                              <1>     pushf
   483                              <1>     push eax
   484                              <1>     push ecx
   485                              <1>     push edx
   486                              <1> 
   487                              <1> ; we will have to do postprocessing after scanf
   488                              <1>     ALIGN_STACK 8
   489                              <1>     push %%read_tmp
   490                              <1> 
   491                              <1> %elifid %2
   492                              <1> ; variable (hope so)
   493                              <1>     pushf
   494                              <1>     push eax
   495                              <1>     push ecx
   496                              <1>     push edx
   497                              <1> 
   498                              <1>     ALIGN_STACK 8    
   499                              <1>     push %2
   500                              <1> %elifnum %2
   501                              <1>     %error "Incorrect parameter (number)"
   502                              <1> %elifstr %2
   503                              <1>     %error "Incorrect parameter (string)"
   504                              <1> %else
   505                              <1> ; may be, address expression?
   506                              <1>     
   507                              <1>     mov dword [%%tmp], eax    ; may use register esp, need to take care
   508                              <1> 
   509                              <1>     lea eax, %2
   510                              <1> 
   511                              <1>     pushf
   512                              <1>     push dword [%%tmp] ; eax
   513                              <1>     push ecx
   514                              <1>     push edx
   515                              <1> 
   516                              <1>     ALIGN_STACK 8
   517                              <1>     push eax
   518                              <1> %endif
   519                              <1> 
   520                              <1>     push %%fmt
   521                              <1>     call scanf
   522                              <1>     UNALIGN_STACK
   523                              <1> 
   524                              <1>     pop edx
   525                              <1>     pop ecx
   526                              <1>     pop eax
   527                              <1>     popf    
   528                              <1> 
   529                              <1> %if %$is_reg = 1
   530                              <1> ; register postprocessing
   531                              <1> 
   532                              <1> %if %$reg_size = %1
   533                              <1>     mov %2, [%%read_tmp]
   534                              <1> %else ; extend bytes 1 -> 2, 1 -> 4, 2 -> 4
   535                              <1>     %if %1 = 1
   536                              <1>         %4 %2, byte [%%read_tmp]
   537                              <1>     %else ; 2 -> 4
   538                              <1>         %4 %2, word [%%read_tmp]
   539                              <1>     %endif
   540                              <1> %endif
   541                              <1> 
   542                              <1> %endif
   543                              <1> 
   544                              <1>     %pop ; IS_REG
   545                              <1> %endmacro
   546                              <1> 
   547                              <1> %macro GET_HEX 2.nolist
   548                              <1>     sasmMacroFunc
   549                              <1>     ___GET_NUM_COMMON %1, %2, "x", movzx
   550                              <1>     sasmMacroFuncE
   551                              <1> %endmacro
   552                              <1> 
   553                              <1> %macro GET_DEC 2.nolist
   554                              <1>     sasmMacroFunc
   555                              <1>     ___GET_NUM_COMMON %1, %2, "d", movsx
   556                              <1>     sasmMacroFuncE
   557                              <1> %endmacro
   558                              <1> 
   559                              <1> %macro GET_UDEC 2.nolist
   560                              <1>     sasmMacroFunc
   561                              <1>     ___GET_NUM_COMMON %1, %2, "u", movzx
   562                              <1>     sasmMacroFuncE
   563                              <1> %endmacro
   564                              <1> 
   565                              <1> 
   566                              <1> %macro GET_CHAR 1.nolist
   567                              <1>     sasmMacroFunc
   568                              <1> 
   569                              <1>     jmp %%after_data
   570                              <1> section .data
   571                              <1>     %%fmt db "%c", 0
   572                              <1>     %%tmp dd 0
   573                              <1>     %%read_tmp db 0
   574                              <1> 
   575                              <1> section .text
   576                              <1> %%after_data:
   577                              <1> 
   578                              <1>     IS_GPR %1
   579                              <1> 
   580                              <1> %if %$is_reg = 1
   581                              <1> ; register
   582                              <1> 
   583                              <1>     %ifidni %1, esp
   584                              <1>         %error "Won't read to esp!" 
   585                              <1>     %elifidni %1, sp
   586                              <1>         %error "Won't read to sp!" 
   587                              <1>     %elifidni %1, spl
   588                              <1>         %error "Won't read to spl!" 
   589                              <1>     %endif
   590                              <1> 
   591                              <1>     pushf
   592                              <1>     push eax
   593                              <1>     push ecx
   594                              <1>     push edx
   595                              <1> 
   596                              <1>     ALIGN_STACK 8
   597                              <1> ; we will have to do postprocessing after scanf
   598                              <1>     push %%read_tmp
   599                              <1> 
   600                              <1> %elifid %1
   601                              <1> ; variable (hope so)
   602                              <1>     pushf
   603                              <1>     push eax
   604                              <1>     push ecx
   605                              <1>     push edx
   606                              <1> 
   607                              <1>     ALIGN_STACK 8
   608                              <1>     push %1
   609                              <1>     
   610                              <1> %elifnum %1
   611                              <1>     %error "Incorrect parameter (number)"
   612                              <1> %elifstr %1
   613                              <1>     %error "Incorrect parameter (string)"
   614                              <1> %else
   615                              <1> ; may be, address expression?
   616                              <1>     
   617                              <1>     mov dword [%%tmp], eax    ; may use register esp, need to take care
   618                              <1> 
   619                              <1>     lea eax, %1
   620                              <1> 
   621                              <1>     pushf
   622                              <1>     push dword [%%tmp] ; eax
   623                              <1>     push ecx
   624                              <1>     push edx
   625                              <1> 
   626                              <1>     ALIGN_STACK 8
   627                              <1>     push eax
   628                              <1> %endif
   629                              <1> 
   630                              <1>     push %%fmt
   631                              <1>     call scanf
   632                              <1>     UNALIGN_STACK
   633                              <1> 
   634                              <1>     pop edx
   635                              <1>     pop ecx
   636                              <1>     pop eax
   637                              <1>     popf    
   638                              <1> 
   639                              <1> %if %$is_reg = 1
   640                              <1> ; register postprocessing
   641                              <1> 
   642                              <1> %if %$reg_size = 1
   643                              <1>     mov %1, byte [%%read_tmp]
   644                              <1> %else ; zero extend bytes 1 -> 2, 1 -> 4
   645                              <1>     movzx %1, byte [%%read_tmp]
   646                              <1> %endif
   647                              <1> 
   648                              <1> %endif
   649                              <1> 
   650                              <1>     %pop ; IS_REG
   651                              <1>     sasmMacroFuncE
   652                              <1> %endmacro
   653                              <1> 
   654                              <1> 
   655                              <1> %macro GET_STRING 2.nolist
   656                              <1>     sasmMacroFunc
   657                              <1> 
   658                              <1>     IS_GPR %1
   659                              <1> 
   660                              <1> %if %$is_reg = 1
   661                              <1>     %error "Incorrect 1st parameter (register)"
   662                              <1> %endif
   663                              <1>     
   664                              <1> 
   665                              <1>     %pop
   666                              <1> 
   667                              <1>     IS_GPR %2
   668                              <1> 
   669                              <1> %if %$is_reg = 1
   670                              <1>     ;
   671                              <1> %elifnum %2
   672                              <1>     %if %2 <= 0
   673                              <1>         %error "Second parameter must be positive"
   674                              <1>     %endif
   675                              <1> %else  
   676                              <1>     %error "Second parameter must be numeric constant or register"
   677                              <1> %endif
   678                              <1> 
   679                              <1>     %pop
   680                              <1> 
   681                              <1> %ifid %1
   682                              <1> ; variable (hope so)
   683                              <1>     push esi
   684                              <1>     ;count
   685                              <1>     IS_GPR %2
   686                              <1>     %if %$is_reg = 1 
   687                              <1>         %if %$reg_size = 1
   688                              <1>             movzx esi, %2
   689                              <1>         %elif %$reg_size = 2
   690                              <1>             movzx esi, %2
   691                              <1>         %else ; %$reg_size = 4
   692                              <1>             mov esi, %2
   693                              <1>         %endif
   694                              <1>     %else
   695                              <1>         mov esi, %2
   696                              <1>     %endif
   697                              <1>     %pop
   698                              <1>     
   699                              <1>     pushf
   700                              <1>     push eax
   701                              <1>     push ecx
   702                              <1>     push edx
   703                              <1>     ALIGN_STACK 0
   704                              <1>     call get_stdin
   705                              <1>     UNALIGN_STACK
   706                              <1>     ALIGN_STACK 12
   707                              <1>     push eax
   708                              <1>     push esi ; count
   709                              <1>     push %1
   710                              <1> %elifnum %1
   711                              <1>     %error "Incorrect 1st parameter (number)"
   712                              <1> %elifstr %1
   713                              <1>     %error "Incorrect 1st parameter (string)"
   714                              <1> %else
   715                              <1> ; may be, address expression?
   716                              <1>     
   717                              <1>     jmp %%after_data
   718                              <1> section .data
   719                              <1>     %%tmp dd 0
   720                              <1> section .text
   721                              <1> %%after_data:
   722                              <1> 
   723                              <1>     ; may use register esp, need to take care
   724                              <1>     mov dword [%%tmp], edi
   725                              <1>     lea edi, %1
   726                              <1>     
   727                              <1>     push esi
   728                              <1>     ;count
   729                              <1>     IS_GPR %2
   730                              <1>     %if %$is_reg = 1 
   731                              <1>         %if %$reg_size = 1
   732                              <1>             movzx esi, %2
   733                              <1>         %elif %$reg_size = 2
   734                              <1>             movzx esi, %2
   735                              <1>         %else ; %$reg_size = 4
   736                              <1>             mov esi, %2
   737                              <1>         %endif
   738                              <1>     %else
   739                              <1>         mov esi, %2
   740                              <1>     %endif
   741                              <1>     %pop
   742                              <1> 
   743                              <1>     pushf
   744                              <1>     push eax
   745                              <1>     push ecx
   746                              <1>     push edx
   747                              <1>     ALIGN_STACK 0
   748                              <1>     call get_stdin
   749                              <1>     UNALIGN_STACK
   750                              <1>     ALIGN_STACK 12
   751                              <1>     push eax    
   752                              <1>     push esi ; count
   753                              <1>     push edi
   754                              <1>  
   755                              <1>     mov edi, dword [%%tmp]
   756                              <1> %endif
   757                              <1> 
   758                              <1>     call fgets
   759                              <1>     UNALIGN_STACK
   760                              <1> 
   761                              <1>     pop edx
   762                              <1>     pop ecx
   763                              <1>     pop eax
   764                              <1>     popf
   765                              <1>     pop esi
   766                              <1>     sasmMacroFuncE
   767                              <1> %endmacro
   768                              <1> %endif
   769                              <1> 
     2                                  
     3                                  section .data
     4 00000000 0A496E70757420736F-         input_call: db 10, "Input some matrix:", 10, 13, 0
     4 00000009 6D65206D6174726978-
     4 00000012 3A0A0D00           
     5 00000016 0A596F7220696E7075-         check_call: db 10, "Yor input is:", 10, 13, 0
     5 0000001F 742069733A0A0D00   
     6 00000027 0A416E737765722069-         answer_call: db 10, "Answer is:", 10, 13, 0
     6 00000030 733A0A0D00         
     7                                  
     8                                  section .bss
     9 00000000 <res 60h>                   matrix resd 24
    10                                  
    11                                  section .text
    12                                  global CMAIN
    13                                  
    14                                  ANSWER_PREPARING: ; Works after CHECK_PRINT only if it' s the first result print
    15 00000000 E802000000EB6AEB00-         PRINT_STRING answer_call
    15 00000035 00000000538B5C2404-
    15 0000000E 891D[35000000]8B1C-
    15 00000016 24895C24045B5B9C52-
    15 0000001F 5150C800000083EC00-
    15 00000028 83E4F083C400E8-    
    15 0000002F (00000000)C9C80000-
    15 00000037 0083EC0883E4F083C4-
    15 00000040 085068[27000000]E8-
    15 00000048 (00000000)C9C80000-
    15 00000050 0083EC0483E4F083C4-
    15 00000059 04E8(00000000)50E8-
    15 00000061 (00000000)C958595A-
    15 00000069 9DFF35[35000000]C3 
    16 00000071 EB05                        jmp PRINT_RESULT
    17                                  PRINT_CHECK: ; Every result start point
    18 00000073 83F906                      cmp ecx, 6
    19 00000076 7488                        je ANSWER_PREPARING
    20                                  PRINT_RESULT: ; Main print block
    21 00000078 E802000000EB6AEB00-         PRINT_DEC 4, eax
    21 00000039 00000000538B5C2404-
    21 00000086 891D[39000000]8B1C-
    21 0000008E 24895C24045B5BEB03-
    21 00000097 256400EB0000000000-
    21 0000009C A3[3D000000]89C09C-
    21 000000A4 FF35[3D000000]5152-
    21 000000AC C800000083EC0883E4-
    21 000000B5 F083C4085068-      
    21 000000BB [97000000]E8-      
    21 000000C0 (00000000)C9C80000-
    21 000000C8 0083EC0483E4F083C4-
    21 000000D1 04E8(00000000)50E8-
    21 000000D9 (00000000)C95A5958-
    21 000000E1 9DFF35[39000000]C3 
    22 000000E9 E802000000EB6EEB00-         PRINT_STRING " "
    22 00000041 00000000538B5C2404-
    22 000000F7 891D[41000000]8B1C-
    22 000000FF 24895C24045B5B9C52-
    22 00000108 5150EB022000C80000-
    22 00000111 0083EC0083E4F083C4-
    22 0000011A 00E8(00000000)C9C8-
    22 00000122 00000083EC0883E4F0-
    22 0000012B 83C4085068-        
    22 00000130 [0C010000]E8-      
    22 00000135 (00000000)C9C80000-
    22 0000013D 0083EC0483E4F083C4-
    22 00000146 04E8(00000000)50E8-
    22 0000014E (00000000)C958595A-
    22 00000156 9DFF35[41000000]C3 
    23 0000015E 83F900                      cmp ecx, 0 ; If cycle is not finished - jump into end of current iteration
    24 00000161 0F856E020000                jnz CONTINUE
    25                                  
    26                                  CMAIN:
    27 00000167 89E5                        mov ebp, esp ; For debuuging
    28 00000169 31C0                        xor eax, eax ; Eax cleaning
    29 0000016B B918000000                  mov ecx, 24 ; Counter for matrix consistent input
    30 00000170 BF00000000                  mov edi, 0 ; DWORD index
    31 00000175 E802000000EB6AEB00-         PRINT_STRING input_call
    31 00000045 00000000538B5C2404-
    31 00000183 891D[45000000]8B1C-
    31 0000018B 24895C24045B5B9C52-
    31 00000194 5150C800000083EC00-
    31 0000019D 83E4F083C400E8-    
    31 000001A4 (00000000)C9C80000-
    31 000001AC 0083EC0883E4F083C4-
    31 000001B5 085068[00000000]E8-
    31 000001BD (00000000)C9C80000-
    31 000001C5 0083EC0483E4F083C4-
    31 000001CE 04E8(00000000)50E8-
    31 000001D6 (00000000)C958595A-
    31 000001DE 9DFF35[45000000]C3 
    32                                      
    33                                  INPUT_MATRIX_CYCLE:
    34 000001E6 E802000000EB56EB00-         GET_DEC 4, [matrix+edi*4] ; Matrix - relative address of matrix
    34 00000049 00000000538B5C2404-
    34 000001F4 891D[49000000]8B1C-
    34 000001FC 24895C24045B5BEB03-
    34 00000205 256400EB0000000000-
    34 00000051 00000000A3-        
    34 0000020B [4D000000]8D04BD-  
    34 00000212 [00000000]9CFF35-  
    34 00000219 [4D000000]5152C800-
    34 00000221 000083EC0883E4F083-
    34 0000022A C4085068[05020000]-
    34 00000232 E8(00000000)C95A59-
    34 0000023A 589DFF35[49000000]-
    34 00000242 C3                 
    35 00000243 47                          inc edi
    36 00000244 E2A0                        loop INPUT_MATRIX_CYCLE
    37                                      
    38                                  output_matrix_prepare:
    39 00000246 B918000000                  mov ecx, 24
    40 0000024B BF00000000                  mov edi, 0
    41 00000250 E802000000EB6AEB00-         PRINT_STRING check_call
    41 00000055 00000000538B5C2404-
    41 0000025E 891D[55000000]8B1C-
    41 00000266 24895C24045B5B9C52-
    41 0000026F 5150C800000083EC00-
    41 00000278 83E4F083C400E8-    
    41 0000027F (00000000)C9C80000-
    41 00000287 0083EC0883E4F083C4-
    41 00000290 085068[16000000]E8-
    41 00000298 (00000000)C9C80000-
    41 000002A0 0083EC0483E4F083C4-
    41 000002A9 04E8(00000000)50E8-
    41 000002B1 (00000000)C958595A-
    41 000002B9 9DFF35[55000000]C3 
    42                                      
    43                                  OUTPUT_MATRIX_CYCLE:
    44 000002C1 E802000000EB6FEB00-         PRINT_DEC 4, [matrix+edi*4]
    44 00000059 00000000538B5C2404-
    44 000002CF 891D[59000000]8B1C-
    44 000002D7 24895C24045B5BEB03-
    44 000002E0 256400EB0000000000-
    44 000002E5 A3[5D000000]8B04BD-
    44 000002ED [00000000]9CFF35-  
    44 000002F4 [5D000000]5152C800-
    44 000002FC 000083EC0883E4F083-
    44 00000305 C4085068[E0020000]-
    44 0000030D E8(00000000)C9C800-
    44 00000315 000083EC0483E4F083-
    44 0000031E C404E8(00000000)50-
    44 00000326 E8(00000000)C95A59-
    44 0000032E 589DFF35[59000000]-
    44 00000336 C3                 
    45 00000337 47                          inc edi
    46 00000338 E287                        loop OUTPUT_MATRIX_CYCLE
    47                                      
    48                                      
    49                                  cycle_through_columns_prepare:
    50 0000033A 31C0                        xor eax, eax
    51 0000033C 31FF                        xor edi, edi
    52 0000033E B906000000                  mov ecx, 6 ; Main counter - number of columns
    53 00000343 E802000000EB6EEB00-         NEWLINE
    53 00000061 00000000538B5C2404-
    53 00000351 891D[61000000]8B1C-
    53 00000359 24895C24045B5B9C52-
    53 00000362 5150EB020A00C80000-
    53 0000036B 0083EC0083E4F083C4-
    53 00000374 00E8(00000000)C9C8-
    53 0000037C 00000083EC0883E4F0-
    53 00000385 83C4085068-        
    53 0000038A [66030000]E8-      
    53 0000038F (00000000)C9C80000-
    53 00000397 0083EC0483E4F083C4-
    53 000003A0 04E8(00000000)50E8-
    53 000003A8 (00000000)C958595A-
    53 000003B0 9DFF35[61000000]C3 
    54                                      
    55                                  MAIN_CYCLE:
    56 000003B8 51                          push ecx ; Put main counter into the stack
    57 000003B9 B904000000                  mov ecx, 4 ; Now current counter equals sub counter
    58 000003BE 31DB                        xor ebx, ebx ; Base register cleaning
    59                                  SUB_CYCLE:
    60 000003C0 03849F[00000000]            add eax, [ebx*4 + edi + matrix] ; EBX*4 points on current row byte
    61 000003C7 83C306                      add ebx, 6 ; Every sixth index is next element in current column
    62 000003CA E2F4                        loop SUB_CYCLE
    63 000003CC 59                          pop ecx ; Get main counter after sub_cycle ending
    64 000003CD 83C704                      add edi, 4 ; Jump on the next column byte
    65 000003D0 E99EFCFFFF                  jmp PRINT_CHECK ; IO macros are bigger than 128 bytes, it will fix cycle process
    66                                  CONTINUE: ; Iteration finalization
    67 000003D5 31C0                        xor eax, eax
    68 000003D7 E2DF                        loop MAIN_CYCLE
    69                                  
    70                                  FINALIZATION:
    71 000003D9 E802000000EB6EEB00-         NEWLINE
    71 00000065 00000000538B5C2404-
    71 000003E7 891D[65000000]8B1C-
    71 000003EF 24895C24045B5B9C52-
    71 000003F8 5150EB020A00C80000-
    71 00000401 0083EC0083E4F083C4-
    71 0000040A 00E8(00000000)C9C8-
    71 00000412 00000083EC0883E4F0-
    71 0000041B 83C4085068-        
    71 00000420 [FC030000]E8-      
    71 00000425 (00000000)C9C80000-
    71 0000042D 0083EC0483E4F083C4-
    71 00000436 04E8(00000000)50E8-
    71 0000043E (00000000)C958595A-
    71 00000446 9DFF35[65000000]C3 
    72 0000044E C3                          ret
    73                                      
