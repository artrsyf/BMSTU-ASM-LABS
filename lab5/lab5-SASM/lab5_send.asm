%include "io.inc"

section .data
    a: db "qwerwqe\", 0
    a2: db "qwer wq e\", 0
    b: dd 13
    
section .bss
    answer resb 100
 
section .text
global CMAIN
_Z4str1PKcPc:
    ;prolog
    push ebp
    mov ebp,esp
    push edi
    push esi
    push edx
    
    ;Подготовка к обходу строки
    mov al, ' '
    xor ebx, ebx
    xor ecx, ecx
    xor esi, esi
    xor edx, edx
    cld
cycle: ; Данный цикл проверяет текущий символ исходной строки, если он '\', значит, строка полностью пройдена,
                                                                                    ;переходим на блок end_string
    mov dl, [edi]       
    cmp dl, '\'
    je end_string
    
    inc ecx ; Счетчик символов в строке 
    scasb ; Если же текущий символ - пробел, переходим на блок обработки white_space
    je white_space
    
    jmp cycle  
white_space: ; Данный блок просто считает количество пробелов
    inc esi ; Увеличиваем количетсво пробелов и переходим дальше в цикл
    jmp cycle
end_string:
    push esi ; Записываем в стек количество пробелов
    push ecx ; Записываем в стек длину строки (*)
    mov ecx, [esp+12] ; Записываем в ECX длину, до которой нам нужно увелчить строку
    sub ecx, [esp] ; Вычитаем из Нобходимой длины текущую длину строки (расположена в стеке строка (*))
    push ecx ; Записываем в стек количество добавляемых пробелов

    cmp esi, 0 ; Проверяем в ESI колчиество пробелов для выбора обработки
    je small_block
    jmp big_block
    
small_block: ; Данный блок обрабатывает строку, в которой нет пробелов. Передаем параметры из стека:
    mov ecx, [esp] ; Записываем количество добавляемых пробелов
    mov esi, [esp+20] ; Записываем адрес исходной функции - источника
    mov edi, [esp+12] ; Записываем адрес пустой строки - приемника (результат)
    mov al, ' '
    cld   
    cycle2: ; В ECX количество добавляемых пробелов, данный цикл просто добавляет пробелы в строку - приемник
         mov [edi], al
         inc edi
         loop cycle2
    mov ecx, [esp+4] ; Записываем в ECX длину исходной строки
    rep movsb ; Просто копируем содержимое строки - источника в строку - приемник (коппируем после добавленных пробелов)
    jmp finalization ; Переходим в завершающий блок

big_block: ; Данный блок обрабатывает строку в которой есть пробелы путем увелчения их количества
    ; Передаем параметры из стека:
    mov eax, [esp] ; Записываем количество добавляемых пробелов
    mov ecx, [esp+8] ; Записываем число пробелов в исходной строке
    cdq
    idiv ecx ; На данном шаге мы получаем в eax число пробелов, которые мы должны добавить после каждого пробела исходной строки
    push eax ; На каждый встреченный пробел в исходной строке мы добавляем eax пробелов
    push edx ; Остаток деления (добавляется после любого пробела)
    mov edi, [esp+20] ; Адрес результата (строки - приемника)
    mov esi, [esp+28] ; Адрес исходной строки (строки - источника)
    mov ecx, [esp+12] ; Длина исходной строки
    mov al, ' '    
    cld
     
    cycle3: ; Данный внешний цикл проходит по исходной строке
        cmp [esi], al ; Если встретили пробел, переходим в обработку (блок process)
        je process
        movsb ; Если не пробел просто переписываем симпол из источника в приемник
        jmp cycle3_end ; Переходим к концу итерации
        process: ; Если же мы нашли пробел
            push ecx ; Заносим в стек внешний счетчик (**)
            mov ecx, [esp+8] ; Заносим в  ECX количество добавляемых пробелов на один пробел источника (учитывая операцию (**))
            inc esi ; Переносим каретку исходной строки на 1 для следующей итерации
            mov [edi], al ; Добавляем пробел строки - источника в строку - приемник
            inc edi ; Смещаем каретку приемника на 1
            cycle3_2: ; На данном этапе мы встретили пробел в источника, добавили его в приемник, теперь нужно добавить
                      ; несколько пробелов (их количество записано в ecx)
                mov [edi], al ; Добавляем пробел в строку - приемник
                inc edi ; Смещаем каретку приемника на 1
                loop cycle3_2
            pop ecx ; Возвращаем счтечик внешнего цикла
        cycle3_end: ; Конец итерации
            loop cycle3

    big_block_finalization: ; Процесс заврешения после работы блока big_block
                            ; Данный блок имеет место быть, потому что стек после блока small_block отличен от стека
                            ; блока big_block
        pop ecx ; Достаем остаток пробелов
        PRINT_DEC 4, ECX
        NEWLINE
        pop ecx ; Достаем количество пробелов, добавляемых в приемник на каждый пробел источника
        PRINT_DEC 4, ECX
        NEWLINE 

                 
finalization: ; Блок завершения работы программы
    pop ecx ; Достаем количество добавляемых пробелов (общее для приемника)
    PRINT_DEC 4, ECX
    NEWLINE
    pop ecx ; Достаем длину исходной строки
    PRINT_DEC 4, ECX
    NEWLINE
    pop ecx ; Достаем число пробелов
    PRINT_DEC 4, ECX
    NEWLINE
    pop edx  ; Достаем адрес результата
    
    ;epilog
    pop esi
    pop edi   
    mov esp,ebp
    pop ebp
    mov eax, 3
    ; По итогу стек был возвращен в исходное состояние, результат был записан в edx (третий параметр при передаче)
    ret


CMAIN:
    mov ebp, esp; for correct debugging
    
    ;System V convention: передаю три параметра в регистрах EDI, ESI, EDX
    lea edi, [a2] ;Адрес передваемой строки
    mov esi, [b] ;Размер, до которого нужно увеличить путем добавления проблеов между слов
    lea edx, [answer] ;Адрес результата работы программы
    ; Передаю 3 параметры специально в описанные выше регистры, чтобы по макимому приблизить данную программу
    ; к модулю для С++
    call _Z4str1PKcPc
    PRINT_STRING [EDX] ;Вывод результирующей строки по адресу, записанноу в EDX
    NEWLINE
    PRINT_STRING [EDI] ;Вывод исходной строки по адресу, записанноу в EDI
    NEWLINE
    ret